\section{OW-ChCCA-KEM实现}
\label{chap:owchccakem}

实现TIMKE协议的核心是构建OW-ChCCA KEM，与广泛使用的IND-CCA2 KEM不同，OW-ChCCA安全模型引入了独特的可检测性属性。遵循论文\cite{pan_lattice-based_2023}提出的理论框架，本章详细介绍基于格的OW-ChCCA KEM（以下简称OW-ChCCA-KEM）实现，包括核心数据结构设计、算法实现以及性能优化。

\subsection{OW-ChCCA安全简述}

单向可检测选择密文（OW-ChCCA）安全是论文 \cite{pan_lattice-based_2023} 提出的一种安全模型，旨在构造紧致安全性的认证密钥交换（Authenticated Key Exchange, AKE）协议。OW-ChCCA安全与传统的不可区分选择密文安全（IND-CCA）有许多区别，IND-CCA要求攻击者在选择密文攻击的游戏下无法区分挑战密文封装的密钥，即使攻击者多次请求解密任意非挑战密文，而OW-ChCCA则专注于单向性（One-Wayness），要求攻击者难以从密文中恢复出封装的密钥，不保证密钥的不可区分，弱化某些场景的安全保证，但足够支持特定构造的安全需求。OW-ChCCA安全模型还引入“可检测性”（Checkability），攻击者被赋予验证猜测密钥/密文对有效性的能力，由Check Oracle检测其猜测是否正确，扩展OW-PCA安全的同时还结合了选择密文攻击的元素。

在多用户的AKE环境下，系统可能需要在同一时段应对源自多个会话的攻击，每个会话可能涉及不同用户及密钥对。OW-ChCCA安全的多用户设置确保即使攻击者可以访问多个挑战密文并泄露部分私钥，仍能维持所嵌入实例的整体安全。

\subsection{实现架构}

架构采用模块化设计，将系统分解为相互独立但协同工作的功能组件，提高了代码的可维护性和可测试性，为后期性能瓶颈的优化创造了条件，实现主要包含以下核心组件：

\textbf{密钥封装机制（KEM）接口层}定义标准化的KEM操作接口，包括密钥生成（KeyGen）、封装（Encaps）和解封装（Decaps），与现代密码库的KEM实现规范保持一致。自实现的OW-ChCCA-KEM能够通过简单的接口适配与其他软件系统无缝集成。考虑到未来可能构建混合加密的方案，接口设计考虑了与其他KEM实现（如ML-KEM）的互操作性。

\textbf{矩阵运算库}是OW-ChCCA-KEM实现的计算核心。早期开发测试结果显示，基于LWE问题的矩阵运算会影响整体的执行效率，成为主要的性能瓶颈，尤其是处理高维矩阵。针对这一问题，通过抽象出矩阵运算的操作，将主要的运算操作汇集在该库，通过整体优化模运算、矩阵乘法等操作，实现并行化算法以充分利用现代多核处理器的计算能力，提升运算效率。

\textbf{参数管理系统}负责管理不同安全级别参数集，提供参数验证和动态注册的机制，允许用户根据具体安全需求自定义安全等级、矩阵维度、模数等关键参数。系统内置参数验证功能，通过数学计算以及约束判断，确保用户选择的参数满足理论安全需求，防止错误参数导致的安全风险。

\textbf{哈希扩展函数}用于扩展随机种子为算法所需的各种参数，以及派生共享密钥。

\textbf{并行计算优化}针对大规模矩阵运算提供并行实现，充分利用多核处理器资源。除了基础的矩阵运算并行，实现还集成多种并行与分块策略以应对OW-ChCCA-KEM展现的计算密集性，以提高矩阵采样、结果验证等步骤的效率，这部分的性能提升在公私钥对生成的阶段下尤为明显。

\input{doc/owchcca/owchccaDS}

\subsection{性能优化}

实现OW-ChCCA-KEM要求确保理论安全的同时降低其计算复杂性和资源需求，在传统计算设备上可行。OW-ChCCA-KEM基于LWE问题的构造需要大维度矩阵和高精度计算，实际运行会导致极高的计算负担和存储开销。实现在设计初期就将矩阵运算效率作为重点优化目标，采用专门设计的矩阵和向量类，提供模运算加速的支持并实现其他优化。

首先，引入动态并行处理机制，系统根据输入数据规模自动决定是否启用并行计算，当矩阵维度超过预设阈值（ParallelStart）时切换到多线程模式，避免了小矩阵运算带来额外的线程管理开销。例如，生成公钥矩阵$\mathbf{A}$的过程会被分割为多个独立任务，分配给不同处理线程，系统根据可用CPU核心数动态调整并行度，在多核处理器上实现近线性的加速。

其次，针对向量和矩阵的基本操作进行算法优化。向量操作（如加法、点积）实现并行处理机制，当向量维度超过设定阈值时自动启用多线程计算。矩阵转置和最关键的矩阵乘法操作（如$\mathbf{A}\mathbf{Z}_b$、$\mathbf{A}^T\mathbf{s}$等）操作采用分块并行策略，每个线程负责矩阵的一个区块。表\ref{tab:complexity-analysis}总结了主要矩阵运算的时间复杂度和优化效果。其中$n$、$m$、$k$分别为矩阵维度，$p$为并行处理核心数。测试结果表明，在8核处理器上，矩阵乘法操作实际获得了约5.3倍的加速比，略低于理论线性加速，主要受限于内存带宽和线程协调开销。

\begin{table}[ht]
\centering
\caption{OW-ChCCA-KEM主要操作的计算复杂度分析}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{操作} & \textbf{串行实现复杂度} & \textbf{并行实现复杂度} & \textbf{加速比} \\
\hline
矩阵乘法 & $\mathcal{O}(nmk)$ & $\mathcal{O}(nmk/p)$ & $\approx p$ \\
\hline
矩阵转置 & $\mathcal{O}(nm)$ & $\mathcal{O}(nm/p)$ & $\approx p$ \\
\hline
向量加法 & $\mathcal{O}(n)$ & $\mathcal{O}(n/p)$ & $\approx p$ \\
\hline
模运算 & $\mathcal{O}(n^2)$ & $\mathcal{O}(n^2/p)$ & $\approx 0.8p$ \\
\hline
\end{tabular}
\label{tab:complexity-analysis}
\end{table}

与ML-KEM等成熟KEM方案相比，OW-ChCCA-KEM的性能差距明显，主要源于两个方面：一是LWE问题与环上学习带误差（Ring-LWE）或模基学习带误差（Module-LWE）问题在代数结构上的差异；二是满足OW-ChCCA安全需要较大的模数和维度，基础的运算都需要高精度计算的支持。NIST中ML-KEM方案选择的模数为 3329，基于环的实现使其能在矩阵内部使用数论变换（Number Theoretic Transform, NTT） 加速，使$n$阶环运算上多项式乘法的时间复杂度由简单乘法的$\mathcal{O}{(n^2)}$降低至$\mathcal{O}{(nlgn)}$。而OW-ChCCA-KEM需要在更大的有限域上进行运算，且缺乏类似的代数结构优化策略。

高斯分布采样是另一个影响性能的关键因素。通过评估Golang社区中的多个随机分布实现库，如\href{https://github.com/milosgajdos/go-estimate}{go-estimate}、\href{https://github.com/gonum/gonum}{gonum}、\href{https://github.com/tuneinsight/lattigo}{lattigo}，最终选择 lattigo 中的 NewGaussianSampler 进行离散型高斯分布的采样。主要基于如下几点考虑，该库中的其他函数可作为OW-ChCCA-KEM实现中的辅助，简化了外部库调用带来的不确定性，并且该库的维护及生态较其他相比更加活跃，许多代码的潜在问题都有维护者积极响应，提供的文档也十分清晰。这也影响了矩阵计算的优化设计。lattigo中的NewGaussianSampler需要基于库内的环结构体才能调用，且环的模数需要为 NTT友好（NTT-Friendly）素数或剩余数系统（Residue Number System, RNS）。理论方案要求进行矩阵运算时在$\mathbf{Z}_p$下进行，因此实现上只考虑选择 NTT-Friendly 的素数$p$。进行高斯取样的矩阵大小为$n \times m$，实现选择定义一个阶为$m$的模$p$环。在参数选择阶段，实现针对用户指定的参数寻找符合要求的 NTT-Friendly 的素数，满足$2^\text{BitSize} ± k * \text{NthRoot} + 1$的形式。

以上要求使参数的选定受到一定限制，但借助于环的结构，可以对矩阵的运算进行新的优化。实现将$n \times m$的矩阵表示为$n$个阶为$m$的模$p$多项式。此时，大小为$n\times m$与$m \times k$的矩阵乘法被转化为$nk$次的环上多项式乘法，并可通过Barrett归约加速模运算\cite{r_omondi_modular_2020}。Barrett归约是一种适于固定模数的多运算场景的高效模运算方法。与传统除法直接取余数相比，它通过预计算常量避免昂贵的除法操作。针对固定模数$q$，预先计算常量$r = \lfloor 2^{2k}/q \rfloor$，其中$k$是$q$的比特长度，对于任意$x < q^2$，可以通过以下步骤计算$x \bmod q$：1)计算$t = \lfloor x \cdot r / 2^{2k} \rfloor$，粗略估计$x/q$的值；2)计算$x' = x - t \cdot q$，得到一个接近但可能仍大于模数$q$的结果；3)如果$x' \geq q$，则再减去$q$，获得最终结果。

实现对内存的使用也进行了优化，大整数表示时使用最小必要的字节数存储。对于给定模数$q$，系统自动计算所需的字节数$\lceil\log_2(q)/8\rceil$，避免不必要的内存浪费。在计算环节，矩阵和向量运算尽可能在原地进行，减少临时对象创建。例如，向量加法操作可选的将结果直接写入其中一个输入向量并返回，避免分配新内存。大矩阵运算采用分块策略，每次只处理矩阵的一部分，减少峰值内存使用。密钥和密文序列化采用紧凑编码，减少传输和存储开销。优化后的SHA3实现通过缓冲池减少内存分配，针对不同大小的输入选择最适合的处理策略，返回指定长度的字节数组。

\subsection{扩展性设计}

OW-ChCCA-KEM实现设计时充分考虑了扩展性，为未来技术演进和应用需求变化提供了灵活适应框架。系统参数支持动态配置和管理，可依照不同安全与性能需求通过参数注册机制设定新参数，无需修改核心代码，灵活应对未来安全标准变化。核心组件采用高度的模块化设计，支持模块单独的替换和升级，关键算法组件如高斯采样器、哈希函数、矩阵运算库等都有明确接口定义以便同其他模块交互，未来可以集成更高效的高斯采样算法，或者替换哈希函数而不影响系统的整体架构。实现还考虑其跨平台兼容能力，大规模矩阵运算可通过CUDA、OpenCL等重新实现，以支持对应计算平台的加速。自实现的KEM与TIMKE协议的KEM接口兼容，能够与其他KEM（如ML-KEM）无缝集成，组合出满足不同需求的混合方案，适应不同的应用场景。

\subsection{小结}

本章详细介绍基于LWE问题的OW-ChCCA-KEM实现，尽管通过各种优化措施提高了OW-ChCCA-KEM的性能，但与ML-KEM等KEM方案相比，在计算效率和资源需求方面仍存在差距，主要源于LWE问题与环、模格问题在代数结构上的差异，以及满足OW-ChCCA安全所需要的参数规模。OW-ChCCA-KEM实现仍具有一定价值，不仅验证了OW-ChCCA安全构造的可行性，也为TIMKE协议提供了基础组件。模块化和扩展性的设计实现确保系统能够随着技术进步不断改进，为后量子安全通信提供长期支持。
